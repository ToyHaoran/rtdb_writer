

# 分设备代码
问题：map无法并行读写。
放在每个调用方法外部，因为RowSize++问题，无法并发。
速度差不多，放弃。

## 参数
```go
var unitCount int

// 批处理快采点 map[unit_id][P_NUM]:tablet  150个P_NUM，0不用
var rtFastAnalogMap [][151]*client.Tablet
var rtFastAnalogCount []int


```

## login
```go
	if len(params) == 8 {
		tmp1, _ := strconv.ParseInt(params[7], 10, 32)
		unitCount = int(tmp1)
	}
	//fmt.Println(unitCount)
	rtFastAnalogMap = make([][151]*client.Tablet, unitCount)
	rtFastAnalogCount = make([]int, unitCount)
```

## logout
```go
if rtFastAnalogMap != nil {
		for unit := int64(0); unit < int64(unitCount); unit++ {
			if rtFastAnalogMap[unit][1].RowSize > 0 {
				var rtWgAnalog sync.WaitGroup
				for j := 1; j < len(rtFastAnalogMap[unit]); j++ {
					rtWgAnalog.Add(1)
					go func(tablet *client.Tablet) {
						session, _ := sessionPool.GetSession()
						checkError(session.InsertTablet(tablet, false))
						sessionPool.PutBack(session)
						tablet.Reset()
						rtWgAnalog.Done()
					}(rtFastAnalogMap[unit][j])
				}
				rtWgAnalog.Wait()
				rtFastAnalogCount[unit] = 0
			}
		}
	}
```

## 1
```go
if is_fast {
		// 500个测点，一秒约50万条数据。
		for _, an := range analogs {
			id := an.P_NUM // P_NUM从1开始
			if rtFastAnalogMap[unit][id] == nil || rtFastAnalogMap[unit][id].RowSize == 0 {
				device := baseRoot + ".unit" + strconv.FormatInt(unit, 10) + ".fastA.d" + strconv.FormatInt(int64(id), 10)
				rtFastAnalogMap[unit][id], _ = client.NewTablet(device, measurementSchemas, int(batchSize))
			}
			rtFastAnalogMap[unit][id].SetTimestamp(time.UnixMilli(int64(timestamp)).UnixNano(), rtFastAnalogCount[unit])
			for j, col := range getAnalogValues(an) {
				_ = rtFastAnalogMap[unit][id].SetValueAt(col, j, rtFastAnalogCount[unit])
			}
			rtFastAnalogMap[unit][id].RowSize++ // 因为这里导致不能并发处理。
		}
		rtFastAnalogCount[unit]++
		// 数据满后插入
		if rtFastAnalogMap[unit][1].RowSize >= int(batchSize) {
			var rtWgAnalog sync.WaitGroup
			for j := 1; j < len(rtFastAnalogMap[unit]); j++ {
				rtWgAnalog.Add(1)
				go func(tablet *client.Tablet) {
					session, _ := sessionPool.GetSession()
					checkError(session.InsertTablet(tablet, false))
					sessionPool.PutBack(session)
					tablet.Reset()
					rtWgAnalog.Done()
				}(rtFastAnalogMap[unit][j])
			}
			rtWgAnalog.Wait()
			rtFastAnalogCount[unit] = 0
		}
```

# 原来的备份

## 1
```go
// 1写实时模拟量
// magic: 魔数, 用于标记测试数据集
// unit_id: 机组ID
// time: 断面时间戳
// analog_array_ptr: 指向模拟量数组的指针
// count: 数组长度
// is_fast: 当为true时表示写快采点, 当为false时表示写普通点
//
//export write_rt_analog
func write_rt_analog(magic C.int32_t, unit_id C.int64_t, timestamp C.int64_t, analog_array_ptr *C.Analog, count C.int64_t, is_fast C.bool) {
	//fmt.Println("写实时模拟量start")
	deviceCount := int64(count)
	analogs := (*[1 << 30]Analog)(unsafe.Pointer(analog_array_ptr))[:deviceCount:deviceCount]

	measurements := []string{"P_NUM", "AV", "AVR", "Q", "BF", "QF", "FAI", "MS", "TEW", "CST"}
	dataTypes := []client.TSDataType{client.INT32, client.FLOAT, client.FLOAT, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.FLOAT, client.BOOLEAN, client.TEXT, client.INT32}
	getValues := func(an Analog) []interface{} {
		return []interface{}{an.P_NUM, an.AV, an.AVR, an.Q, an.BF, an.QF, an.FAI, an.MS, string(an.TEW), int32(an.CST)}
	}
	measurementSchemas := make([]*client.MeasurementSchema, len(measurements))
	for j := range measurements {
		measurementSchemas[j] = &client.MeasurementSchema{
			Measurement: measurements[j],
			DataType:    dataTypes[j],
		}
	}

	if is_fast {
		// 500个测点，一秒约50万条数据。
		device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".fastA"
		tablet, _ := client.NewTablet(device, measurementSchemas, int(deviceCount))
		for row, an := range analogs {
			tablet.SetTimestamp(time.UnixMilli(int64(timestamp)).UnixNano()+int64(an.P_NUM), row)
			for i, col := range getValues(an) {
				_ = tablet.SetValueAt(col, i, row)
			}
			tablet.RowSize++
		}
		// 快采点数据量少，直接写就行，但要控制连接数
		wg.Add(1)
		_ = threadPool.Invoke(tablet)
	} else {
		if true {
			// 普通点数据量巨大，时间序列融合  一秒15万条数据。
			// 写实时模拟量OK，插入59850条数据，约60万测点
			visualDeviceCount := int64(50) // 虚拟设备数量0～50
			// TODO 如果PNUM是乱序来的怎么办，可以直接放到一个设备中，也可以根据设备%batchSize求余，放在对应table中
			batchSize = deviceCount / visualDeviceCount
			var wgslow sync.WaitGroup
			for num := int64(0); num <= visualDeviceCount; num++ {
				start := num * batchSize
				end := start + batchSize
				if end > deviceCount {
					end = deviceCount
				}
				wgslow.Add(1)
				go func(start, end int, num int64) {
					device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".normalA" + strconv.FormatInt(num, 10)
					rowCount := int(batchSize)
					tablet, _ := client.NewTablet(device, measurementSchemas, rowCount)
					for row, an := range analogs[start:end] {
						tablet.SetTimestamp(time.UnixMilli(int64(timestamp)).UnixNano()+int64(an.P_NUM), row)
						for i, col := range getValues(an) {
							_ = tablet.SetValueAt(col, i, row)
						}
						tablet.RowSize++
					}
					wg.Add(1)
					_ = threadPool.Invoke(tablet)
					wgslow.Done()
				}(int(start), int(end), num)
			}
			wgslow.Wait()
			//fmt.Println(sumaryString(int(deviceCount), is_fast, true))
		}
	}
	//fmt.Println(sumaryString(int(deviceCount), is_fast, true))
}
```
## 1.1
```go
// 1.1 批量写实时模拟量断面
// unit_id: 机组ID
// count: 断面数量
// time: 时间列表, 包含count个时间
// analog_array_array_ptr: 模拟量断面数组, 包含count个断面的模拟量
// array_count: 每个断面中包含值的数量
// 备注: 只有写快采点的时候会调用此接口
//
//export write_rt_analog_list
func write_rt_analog_list(magic C.int32_t, unit_id C.int64_t, timeArray *C.int64_t, analog_array_array_ptr **C.Analog, array_count *C.int64_t, count C.int64_t) {
	//fmt.Println("写实时模拟量断面start")
	sectionCount := int64(count)
	times := (*[1 << 30]C.int64_t)(unsafe.Pointer(timeArray))[:sectionCount:sectionCount]
	analogsArray := (*[1 << 30]*C.Analog)(unsafe.Pointer(analog_array_array_ptr))[:sectionCount:sectionCount]
	arrayCounts := (*[1 << 30]C.int64_t)(unsafe.Pointer(array_count))[:sectionCount:sectionCount]

	totalCount := 0 // 总共多少条数据
	for _, tcount := range arrayCounts {
		totalCount += int(tcount)
	}

	measurements := []string{"P_NUM", "AV", "AVR", "Q", "BF", "QF", "FAI", "MS", "TEW", "CST"}
	dataTypes := []client.TSDataType{client.INT32, client.FLOAT, client.FLOAT, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.FLOAT, client.BOOLEAN, client.TEXT, client.INT32}
	getValues := func(an Analog) []interface{} {
		return []interface{}{an.P_NUM, an.AV, an.AVR, an.Q, an.BF, an.QF, an.FAI, an.MS, string(an.TEW), int32(an.CST)}
	}

	device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".fastA"
	measurementSchemas := make([]*client.MeasurementSchema, len(measurements))
	for j := range measurements {
		measurementSchemas[j] = &client.MeasurementSchema{
			Measurement: measurements[j],
			DataType:    dataTypes[j],
		}
	}
	tablet, _ := client.NewTablet(device, measurementSchemas, totalCount)

	rowStart := 0
	for i := int64(0); i < sectionCount; i++ {
		deviceCount := int64(arrayCounts[i])
		analogs := (*[1 << 30]Analog)(unsafe.Pointer(analogsArray[i]))[:deviceCount:deviceCount]
		for rowI, an := range analogs {
			rowOut := rowStart + rowI
			tablet.SetTimestamp(time.UnixMilli(int64(times[i])).UnixNano()+int64(an.P_NUM), rowOut)
			for j, col := range getValues(an) {
				_ = tablet.SetValueAt(col, j, rowOut)
			}
			tablet.RowSize++
		}
		rowStart += int(deviceCount)
	}
	// 快采点数据量少，直接写就行，但要控制连接数
	wg.Add(1)
	_ = threadPool.Invoke(tablet)
	//fmt.Println("批量写实时模拟量断面OK", sumaryString(totalCount, true, true))
}
```

## 2
```go
// 2写实时数字量
// unit_id: 机组ID
// time: 断面时间戳
// digital_array_ptr: 指向数字量数组的指针
// count: 数组长度
// is_fast: 当为true时表示写快采点, 当为false时表示写普通点
//
//export write_rt_digital
func write_rt_digital(magic C.int32_t, unit_id C.int64_t, timestamp C.int64_t, digital_array_ptr *C.Digital, count C.int64_t, is_fast C.bool) {
	//fmt.Println("写实时数字量start")
	deviceCount := int64(count)
	digitals := (*[1 << 30]Digital)(unsafe.Pointer(digital_array_ptr))[:deviceCount:deviceCount]

	measurements := []string{"P_NUM", "DV", "DVR", "Q", "BF", "FQ", "FAI", "MS", "TEW", "CST"}
	dataTypes := []client.TSDataType{client.INT32, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.TEXT, client.INT32}
	getValues := func(di Digital) []interface{} {
		return []interface{}{di.P_NUM, di.DV, di.DVR, di.Q, di.BF, di.FQ, di.FAI, di.MS, string(di.TEW), int32(di.CST)}
	}

	measurementSchemas := make([]*client.MeasurementSchema, len(measurements))
	for j := range measurements {
		measurementSchemas[j] = &client.MeasurementSchema{
			Measurement: measurements[j],
			DataType:    dataTypes[j],
		}
	}

	if is_fast {
		device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".fastD"
		tablet, _ := client.NewTablet(device, measurementSchemas, int(deviceCount))
		for row, di := range digitals {
			tablet.SetTimestamp(time.UnixMilli(int64(timestamp)).UnixNano()+int64(di.P_NUM), row)
			for i, col := range getValues(di) {
				_ = tablet.SetValueAt(col, i, row)
			}
			tablet.RowSize++
		}
		wg.Add(1)
		_ = threadPool.Invoke(tablet)
	} else {

		if true {
			// 普通点数量多，使用时间序列融合
			// 写实时数字量OK，插入139650条数据，约140万测点。
			visualDeviceCount := int64(100) // 虚拟设备数量
			batchSize = deviceCount / visualDeviceCount
			var wgslow sync.WaitGroup
			for num := int64(0); num <= visualDeviceCount; num++ {
				start := num * batchSize
				end := start + batchSize
				if end > deviceCount {
					end = deviceCount
				}
				wgslow.Add(1)
				go func(start, end int, num int64) {
					device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".normalD" + strconv.FormatInt(num, 10)
					rowCount := int(batchSize)
					tablet, _ := client.NewTablet(device, measurementSchemas, rowCount)
					for row, di := range digitals[start:end] {
						tablet.SetTimestamp(time.UnixMilli(int64(timestamp)).UnixNano()+int64(di.P_NUM), row)
						for i, col := range getValues(di) {
							_ = tablet.SetValueAt(col, i, row)
						}
						tablet.RowSize++
					}
					wg.Add(1)
					_ = threadPool.Invoke(tablet)
					wgslow.Done()
				}(int(start), int(end), num)
			}
			wgslow.Wait()
			//fmt.Println(sumaryString(int(deviceCount), is_fast, false))
		}
	}
	//fmt.Println(sumaryString(int(deviceCount), is_fast, false))
}
```

## 2.1

```go

// 2.1 批量写实时数字量
// unit_id: 机组ID
// count: 断面数量
// time: 时间列表, 包含count个时间
// analog_array_array_ptr: 数字量断面数组, 包含count个断面的数字量
// array_count: 每个断面中包含值的数量
// 备注: 只有写快采点的时候会调用此接口
//
//export write_rt_digital_list
func write_rt_digital_list(magic C.int32_t, unit_id C.int64_t, timeArray *C.int64_t, digital_array_array_ptr **C.Digital, array_count *C.int64_t, count C.int64_t) {
	//fmt.Println("写实时数字量断面start")
	sectionCount := int64(count)
	times := (*[1 << 30]C.int64_t)(unsafe.Pointer(timeArray))[:sectionCount:sectionCount]
	digitalsArray := (*[1 << 30]*C.Digital)(unsafe.Pointer(digital_array_array_ptr))[:sectionCount:sectionCount]
	arrayCounts := (*[1 << 30]C.int64_t)(unsafe.Pointer(array_count))[:sectionCount:sectionCount]

	totalCount := 0 // 总共多少条数据
	for _, tcount := range arrayCounts {
		totalCount += int(tcount)
	}

	measurements := []string{"P_NUM", "DV", "DVR", "Q", "BF", "FQ", "FAI", "MS", "TEW", "CST"}
	dataTypes := []client.TSDataType{client.INT32, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.BOOLEAN, client.TEXT, client.INT32}

	device := baseRoot + ".unit" + strconv.FormatInt(int64(unit_id), 10) + ".fastD"
	measurementSchemas := make([]*client.MeasurementSchema, len(measurements))
	for j := range measurements {
		measurementSchemas[j] = &client.MeasurementSchema{
			Measurement: measurements[j],
			DataType:    dataTypes[j],
		}
	}
	tablet, _ := client.NewTablet(device, measurementSchemas, totalCount)

	rowStart := 0
	for i := int64(0); i < sectionCount; i++ {
		deviceCount := int64(arrayCounts[i])
		digitals := (*[1 << 30]Digital)(unsafe.Pointer(digitalsArray[i]))[:deviceCount:deviceCount]
		for rowI, di := range digitals {
			rowOut := rowStart + rowI
			tablet.SetTimestamp(time.UnixMilli(int64(times[i])).UnixNano()+int64(di.P_NUM), rowOut)
			for j, col := range getDigitalValues(di) {
				_ = tablet.SetValueAt(col, j, rowOut)
			}
			tablet.RowSize++
		}
		rowStart += int(deviceCount)
	}
	// 快采点数据量少，直接写就行，但要控制连接数
	wg.Add(1)
	_ = threadPool.Invoke(tablet)
	//fmt.Println("批量写实时数字量断面OK", sumaryString(int(totalCount), true, false))
}
```
